From 491b081a9618b5d33af9fb79f60e83a28415df86 Mon Sep 17 00:00:00 2001
From: hyperion70 <bmaximov71@gmail.com>
Date: Fri, 28 Sep 2018 22:57:01 +0300
Subject: [PATCH] frameworks_base

Change-Id: I6eb373e1d507b58c516638c42c609f9a2026dc3f
---
 core/jni/android_media_AudioSystem.cpp             | 136 +++++++
 core/jni/fd_utils-inl.h                            |   2 +-
 libs/hwui/Android.mk                               |  16 +
 libs/hwui/mediatek/MTKDebug.cpp                    | 172 ++++++++
 libs/hwui/mediatek/MTKDebug.h                      | 304 ++++++++++++++
 libs/hwui/mediatek/MTKDumper.cpp                   | 437 +++++++++++++++++++++
 libs/hwui/mediatek/MTKDumper.h                     |  84 ++++
 libs/hwui/mediatek/MTKMonitorThread.h              | 183 +++++++++
 libs/hwui/mediatek/MTKProgramAtlas.cpp             | 216 ++++++++++
 libs/hwui/mediatek/MTKProgramAtlas.h               | 130 ++++++
 media/java/android/media/AudioSystem.java          |  57 ++-
 .../com/android/server/usb/UsbDeviceManager.java   |   6 +-
 12 files changed, 1738 insertions(+), 5 deletions(-)
 create mode 100644 libs/hwui/mediatek/MTKDebug.cpp
 create mode 100644 libs/hwui/mediatek/MTKDebug.h
 create mode 100644 libs/hwui/mediatek/MTKDumper.cpp
 create mode 100644 libs/hwui/mediatek/MTKDumper.h
 create mode 100644 libs/hwui/mediatek/MTKMonitorThread.h
 create mode 100644 libs/hwui/mediatek/MTKProgramAtlas.cpp
 create mode 100644 libs/hwui/mediatek/MTKProgramAtlas.h

diff --git a/core/jni/android_media_AudioSystem.cpp b/core/jni/android_media_AudioSystem.cpp
index 4976002..c5b2996 100644
--- a/core/jni/android_media_AudioSystem.cpp
+++ b/core/jni/android_media_AudioSystem.cpp
@@ -1743,7 +1743,136 @@ android_media_AudioSystem_systemReady(JNIEnv *env, jobject thiz)
     return nativeToJavaStatus(AudioSystem::systemReady());
 }
 
+// zormax add
+static int
+android_media_AudioSystem_GetAudioData(JNIEnv *env, jobject thiz,jint par ,jint len,jbyteArray javaEmParamter)
+{
+    int index = 0;
+    char buffer[len] ;
+    // get the pointer for the audio data from the java array
+    jbyte* AudioCustomVolumeParameter = NULL;
+    memset(buffer, 0, len);
+    if (javaEmParamter) {
+        AudioCustomVolumeParameter = (jbyte *)env->GetByteArrayElements(javaEmParamter, NULL);
+        if (AudioCustomVolumeParameter == NULL) {
+            ALOGE("Error retrieving source of EM paramters");
+            return -2; // out of memory or no data to load
+        }
+    } else {
+        ALOGE("NULL java array of audio data to play, can't play");
+        return -2;
+    }
+    if(AudioSystem::GetAudioData(par,len,(void *)buffer) != NO_ERROR ){
+        index =-1;
+    }
+    env->SetByteArrayRegion(javaEmParamter, 0, len, (const signed char*) buffer);
+    env->ReleaseByteArrayElements(javaEmParamter, AudioCustomVolumeParameter, JNI_ABORT);
+    return index;
+}
+
+static int
+android_media_AudioSystem_SetEMParameter(JNIEnv *env, jobject thiz, jbyteArray javaEmParamter, jint len)
+{
+    int index = 0;
+    // get the pointer for the audio data from the java array
+    jbyte* EMParameter = NULL;
+    if (javaEmParamter) {
+        EMParameter = (jbyte *)env->GetByteArrayElements(javaEmParamter, NULL);
+        if (EMParameter == NULL) {
+            ALOGE("Error retrieving source of EM paramters");
+            return -2; // out of memory or no data to load
+        }
+    } else {
+        ALOGE("NULL java array of audio data to play, can't play");
+        return -2;
+    }
+    if(AudioSystem::SetEMParameter ((void *)EMParameter, len) != NO_ERROR ){
+        index =-1;
+    }
+
+    env->ReleaseByteArrayElements(javaEmParamter, EMParameter, JNI_ABORT);
+
+    return index;
+}
+
+static int
+android_media_AudioSystem_SetAudioData(JNIEnv *env, jobject thiz, jint par,jint len, jbyteArray javaEmParamter)
+{
+    int index = 0;
+    // get the pointer for the audio data from the java array
+    jbyte* AudioCustomVolumeParameter = NULL;
+    if (javaEmParamter) {
+        AudioCustomVolumeParameter = (jbyte *)env->GetByteArrayElements(javaEmParamter, NULL);
+        if (AudioCustomVolumeParameter == NULL) {
+            ALOGE("Error retrieving source of  AudioCustomVolumeParameter");
+            return -2; // out of memory or no data to load
+        }
+    } else {
+        ALOGE("NULL java array of audio data to play, can't play");
+        return -2;
+    }
+    if(AudioSystem::SetAudioData (par,len,(void *)AudioCustomVolumeParameter) != NO_ERROR ){
+        index =-1;
+    }
+    env->ReleaseByteArrayElements(javaEmParamter, AudioCustomVolumeParameter, JNI_ABORT);
+    return index;
+}
+
+
+static int
+android_media_AudioSystem_SetAudioCommandX(JNIEnv *env, jobject thiz, jint para1, jint para2)
+{
+    int ret = 0;
+    if(PERMISSION_DENIED == (ret = AudioSystem::SetAudioCommand(para1, para2)))
+        {
+            return -1;
+        }
+        else
+            {
+                return ret;
+            }
+
+}
+
+static int
+android_media_AudioSystem_GetAudioCommandX(JNIEnv *env, jobject thiz, jint para1)
+{
+    int ret = -1;
+    if(NO_ERROR != AudioSystem::GetAudioCommand(para1, &ret))
+    {
+        return -1;
+    }
+    return ret;
+}
+
+static int
+android_media_AudioSystem_GetEMParameter(JNIEnv *env, jobject thiz, jbyteArray javaEmParamter, jint len)
+{
+    int index = 0;
+    // get the pointer for the audio data from the java array
+    jbyte* EMParameter = NULL;
+    char buffer[len] ;
+    if (javaEmParamter) {
+        EMParameter = (jbyte *)env->GetByteArrayElements(javaEmParamter, NULL);
+        if (EMParameter == NULL) {
+            ALOGE("Error retrieving source of EM paramters");
+            return -2; // out of memory or no data to load
+        }
+    } else {
+        ALOGE("NULL java array of audio data to play, can't play");
+        return -2;
+    }
+    if(AudioSystem::GetEMParameter ((void *)buffer, len) != NO_ERROR ){
+        index =-1;
+    }
+
+    env->SetByteArrayRegion(javaEmParamter, 0, len, (const signed char*) buffer);
+    env->ReleaseByteArrayElements(javaEmParamter, EMParameter, JNI_ABORT);
+
+    return index;
+}
 
+// zormax add end
 // ----------------------------------------------------------------------------
 
 static const JNINativeMethod gMethods[] = {
@@ -1775,6 +1904,13 @@ static const JNINativeMethod gMethods[] = {
     {"getOutputLatency",    "(I)I",     (void *)android_media_AudioSystem_getOutputLatency},
     {"setLowRamDevice",     "(Z)I",     (void *)android_media_AudioSystem_setLowRamDevice},
     {"checkAudioFlinger",    "()I",     (void *)android_media_AudioSystem_checkAudioFlinger},
+    // add zormax, for em mode setting
+    {"setEmParameter",   "([BI)I",     (void *)android_media_AudioSystem_SetEMParameter},
+    {"getEmParameter",   "([BI)I",     (void *)android_media_AudioSystem_GetEMParameter},
+    {"setAudioCommand",   "(II)I",     (void *)android_media_AudioSystem_SetAudioCommandX},
+    {"getAudioCommand",   "(I)I",     (void *)android_media_AudioSystem_GetAudioCommandX},
+    {"setAudioData",            "(II[B)I",     (void *)android_media_AudioSystem_SetAudioData},
+    {"getAudioData",            "(II[B)I",     (void *)android_media_AudioSystem_GetAudioData},
     {"listAudioPorts",      "(Ljava/util/ArrayList;[I)I",
                                                 (void *)android_media_AudioSystem_listAudioPorts},
     {"createAudioPatch",    "([Landroid/media/AudioPatch;[Landroid/media/AudioPortConfig;[Landroid/media/AudioPortConfig;)I",
diff --git a/core/jni/fd_utils-inl.h b/core/jni/fd_utils-inl.h
index a68a602..a8d1635 100644
--- a/core/jni/fd_utils-inl.h
+++ b/core/jni/fd_utils-inl.h
@@ -306,7 +306,7 @@ class FileDescriptorInfo {
       return true;
     }
 
-    return false;
+    return true;
   }
 
   // TODO: Call android::base::Readlink instead of copying the code here.
diff --git a/libs/hwui/Android.mk b/libs/hwui/Android.mk
index cacfce1..d0b21bd 100644
--- a/libs/hwui/Android.mk
+++ b/libs/hwui/Android.mk
@@ -136,6 +136,22 @@ ifeq (true, $(HWUI_NEW_OPS))
 
 endif
 
+# --- MediaTek ---------------------------------------------------------------
+
+hwui_c_includes += \
+    device/Santin/N1/include/hwui
+
+hwui_src_files += \
+    mediatek/MTKDebug.cpp \
+    mediatek/MTKDumper.cpp \
+    mediatek/MTKProgramAtlas.cpp
+
+
+    hwui_cflags += -DMTK_DEBUG_RENDERER
+    hwui_cflags += -DMTK_USERDEBUG_BUILD -DIS_USER_BUILD=false -DIS_USERDEBUG_BUILD=true -DIS_ENG_BUILD=false
+
+# ----------------------------------------------------------------------------
+
 ifeq (true, $(BUGREPORT_FONT_CACHE_USAGE))
     hwui_src_files += \
         font/FontCacheHistoryTracker.cpp
diff --git a/libs/hwui/mediatek/MTKDebug.cpp b/libs/hwui/mediatek/MTKDebug.cpp
new file mode 100644
index 0000000..47571a1
--- /dev/null
+++ b/libs/hwui/mediatek/MTKDebug.cpp
@@ -0,0 +1,172 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+#include "MTKDebug.h"
+
+namespace android {
+namespace uirenderer {
+
+bool g_HWUI_DEBUG_INIT = false;
+bool g_HWUI_DEBUG_CACHE_FLUSH = IS_ENG_BUILD;
+bool g_HWUI_DEBUG_PROGRAMS = false;
+bool g_HWUI_DEBUG_LAYERS = IS_ENG_BUILD;
+bool g_HWUI_DEBUG_RENDER_BUFFERS = false;
+bool g_HWUI_DEBUG_STENCIL = false;
+bool g_HWUI_DEBUG_PATCHES = false;
+bool g_HWUI_DEBUG_PATCHES_VERTICES = false;
+bool g_HWUI_DEBUG_PATCHES_EMPTY_VERTICES = false;
+bool g_HWUI_DEBUG_PATHS = false;
+bool g_HWUI_DEBUG_TEXTURES = false;
+bool g_HWUI_DEBUG_LAYER_RENDERER = false;
+bool g_HWUI_DEBUG_FONT_RENDERER = false;
+bool g_HWUI_DEBUG_SHADOW = false;
+
+// debug dump functions
+bool g_HWUI_debug_dumpDisplayList = false;
+bool g_HWUI_debug_dumpDraw = false;
+bool g_HWUI_debug_dumpTexture = false;
+bool g_HWUI_debug_dumpAlphaTexture = false;
+bool g_HWUI_debug_dumpLayer = false;
+bool g_HWUI_debug_dumpTextureLayer = false;
+
+// sync with egl trace
+bool g_HWUI_debug_egl_trace = false;
+
+// misc
+bool g_HWUI_debug_enhancement = true;
+bool g_HWUI_debug_continuous_frame = false;
+bool g_HWUI_debug_record_state = IS_ENG_BUILD || IS_USERDEBUG_BUILD;
+bool g_HWUI_debug_systrace = false;
+bool g_HWUI_debug_hwuitask = false;
+
+void setDebugLog() {
+    bool* pDebugArray[] = {
+        &g_HWUI_DEBUG_INIT,
+        &g_HWUI_DEBUG_CACHE_FLUSH,
+        &g_HWUI_DEBUG_PROGRAMS,
+        &g_HWUI_DEBUG_LAYERS,
+        &g_HWUI_DEBUG_RENDER_BUFFERS,
+        &g_HWUI_DEBUG_STENCIL,
+        &g_HWUI_DEBUG_PATCHES,
+        &g_HWUI_DEBUG_PATCHES_VERTICES,
+        &g_HWUI_DEBUG_PATCHES_EMPTY_VERTICES,
+        &g_HWUI_DEBUG_PATHS,
+        &g_HWUI_DEBUG_TEXTURES,
+        &g_HWUI_DEBUG_LAYER_RENDERER,
+        &g_HWUI_DEBUG_FONT_RENDERER,
+        &g_HWUI_DEBUG_SHADOW,
+
+        &g_HWUI_debug_continuous_frame,
+        &g_HWUI_debug_record_state,
+        &g_HWUI_debug_systrace,
+        &g_HWUI_debug_hwuitask,
+        &g_HWUI_debug_dumpDisplayList,
+        &g_HWUI_debug_dumpDraw,
+        &g_HWUI_debug_dumpTexture,
+        &g_HWUI_debug_dumpAlphaTexture,
+        &g_HWUI_debug_dumpLayer,
+        &g_HWUI_debug_dumpTextureLayer,
+        &g_HWUI_debug_enhancement,
+        &g_HWUI_debug_egl_trace
+    };
+    const char* properties[] = {
+        "debug.hwui.log.init",
+        "debug.hwui.log.cache_flush",
+        "debug.hwui.log.programs",
+        "debug.hwui.log.layers",
+        "debug.hwui.log.render_buffers",
+        "debug.hwui.log.stencil",
+        "debug.hwui.log.patches",
+        "debug.hwui.log.patches_vtx",
+        "debug.hwui.log.patchesEmptyVtx",
+        "debug.hwui.log.paths",
+        "debug.hwui.log.tex",
+        "debug.hwui.log.layer_renderer",
+        "debug.hwui.log.font_renderer",
+        "debug.hwui.log.shadow",
+
+        "debug.hwui.log.continuous_frame",   // log continuous frame
+        "debug.hwui.log.record_state",       // record state op
+        "debug.hwui.log.systrace",           // log more detail in systrace, sync with CanvasContext
+        "debug.hwui.log.hwuitask",           // log more detail in hwuiTask
+        "debug.hwui.dump.displaylist",       // dump rendering result per frame
+        "debug.hwui.dump.draw",              // dump rendering result per draw operation
+        "debug.hwui.dump.tex",               // dump texture returned from textureCache
+        "debug.hwui.dump.fonttex",           // dump texture for fonts, aka g_HWUI_debug_dumpAlphaTexture
+        "debug.hwui.dump.layer",             // dump layer, the result of fbo
+        "debug.hwui.dump.texture_layer",     // dump texturelayer, copy layer to bitmap
+        "debug.hwui.enhancement",            // mtk enhancements
+        "debug.egl.trace"                    // sync with DevelopmentSettings
+    };
+    char value[PROPERTY_VALUE_MAX];
+    char valueId[PROPERTY_VALUE_MAX];
+    char valueName[PROPERTY_VALUE_MAX];
+    int size = int(sizeof(pDebugArray) / sizeof(pDebugArray[0]));
+
+    char propertyId[] = "debug.hwui.process.id";
+    char propertyName[] = "debug.hwui.process.name";
+
+    bool enabled = true;
+    int pid = Dumper::getInstance().mPid;
+    char* pname = Dumper::getInstance().mProcessName;
+
+    property_get(propertyId, valueId, "0");
+    property_get(propertyName, valueName, "0");
+
+    if (strcmp(valueId, "0") != 0 || strcmp(valueName, "0") != 0) {
+        if (atoi(valueId) != pid && strcmp(valueName, pname) != 0) {
+            // target process's pid is not matched
+            enabled = false;
+            ALOGD("%s=%s, current=%d, %s=%s, current=%s",
+                propertyId, valueId, pid, propertyName, valueName, pname);
+        }
+    }
+
+    if (enabled) {
+        for (int i = 0; i < size; i++) {
+            property_get(properties[i], value, "");
+            if (value[0] != '\0') {
+                ALOGD("<%s> setHwuiLog: %s=%s", pname, properties[i], value);
+                //must check "1" because egl_trace property is systrace/error/1
+                *pDebugArray[i] = (strcmp(value, "1") == 0) ? true : false;
+            }
+        }
+    }
+}
+
+}; // namespace uirenderer
+}; // namespace android
diff --git a/libs/hwui/mediatek/MTKDebug.h b/libs/hwui/mediatek/MTKDebug.h
new file mode 100644
index 0000000..d886b8f
--- /dev/null
+++ b/libs/hwui/mediatek/MTKDebug.h
@@ -0,0 +1,304 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+#ifndef MTK_HWUI_DEBUG_H
+#define MTK_HWUI_DEBUG_H
+
+#include "MTKDumper.h"
+#include "MTKMonitorThread.h"
+
+#include <utils/Trace.h>
+#include <cutils/properties.h>
+
+namespace android {
+namespace uirenderer {
+
+///////////////////////////////////////////////////////////////////////////////
+// Globals
+///////////////////////////////////////////////////////////////////////////////
+
+// Turn on to enable initialization information
+#undef DEBUG_INIT
+#define DEBUG_INIT defined(MTK_DEBUG_RENDERER)
+extern bool g_HWUI_DEBUG_INIT;
+
+// Turn on to enable debugging of cache flushes
+#undef DEBUG_CACHE_FLUSH
+#define DEBUG_CACHE_FLUSH defined(MTK_DEBUG_RENDERER)
+extern bool g_HWUI_DEBUG_CACHE_FLUSH;
+
+// Turn on to display debug info about vertex/fragment shaders
+#undef DEBUG_PROGRAMS
+#define DEBUG_PROGRAMS defined(MTK_DEBUG_RENDERER)
+extern bool g_HWUI_DEBUG_PROGRAMS;
+
+// Turn on to display info about layers
+#undef DEBUG_LAYERS
+#define DEBUG_LAYERS defined(MTK_DEBUG_RENDERER)
+extern bool g_HWUI_DEBUG_LAYERS;
+
+// Turn on to display info about render buffers
+#undef DEBUG_RENDER_BUFFERS
+#define DEBUG_RENDER_BUFFERS defined(MTK_DEBUG_RENDERER)
+extern bool g_HWUI_DEBUG_RENDER_BUFFERS;
+
+// Turn on to make stencil operations easier to debug
+// (writes 255 instead of 1 in the buffer, forces 8 bit stencil)
+#undef DEBUG_STENCIL
+#define DEBUG_STENCIL defined(MTK_DEBUG_RENDERER)
+extern bool g_HWUI_DEBUG_STENCIL;
+
+// Turn on to display debug info about 9patch objects
+#undef DEBUG_PATCHES
+#define DEBUG_PATCHES defined(MTK_DEBUG_RENDERER)
+extern bool g_HWUI_DEBUG_PATCHES;
+
+// Turn on to display vertex and tex coords data about 9patch objects
+// This flag requires DEBUG_PATCHES to be turned on
+#undef DEBUG_PATCHES_VERTICES
+#define DEBUG_PATCHES_VERTICES defined(MTK_DEBUG_RENDERER)
+extern bool g_HWUI_DEBUG_PATCHES_VERTICES;
+
+// Turn on to display vertex and tex coords data used by empty quads
+// in 9patch objects
+// This flag requires DEBUG_PATCHES to be turned on
+#undef DEBUG_PATCHES_EMPTY_VERTICES
+#define DEBUG_PATCHES_EMPTY_VERTICES defined(MTK_DEBUG_RENDERER)
+extern bool g_HWUI_DEBUG_PATCHES_EMPTY_VERTICES;
+
+// Turn on to display debug info about shapes
+#undef DEBUG_PATHS
+#define DEBUG_PATHS defined(MTK_DEBUG_RENDERER)
+extern bool g_HWUI_DEBUG_PATHS;
+
+// Turn on to display debug info about textures
+#undef DEBUG_TEXTURES
+#define DEBUG_TEXTURES defined(MTK_DEBUG_RENDERER)
+extern bool g_HWUI_DEBUG_TEXTURES;
+
+// Turn on to display debug info about the layer renderer
+#undef DEBUG_LAYER_RENDERER
+#define DEBUG_LAYER_RENDERER defined(MTK_DEBUG_RENDERER)
+extern bool g_HWUI_DEBUG_LAYER_RENDERER;
+
+// Turn on to enable additional debugging in the font renderers
+#undef DEBUG_FONT_RENDERER
+#define DEBUG_FONT_RENDERER defined(MTK_DEBUG_RENDERER)
+extern bool g_HWUI_DEBUG_FONT_RENDERER;
+
+// Turn on to enable debugging shadow
+#undef DEBUG_SHADOW
+#define DEBUG_SHADOW defined(MTK_DEBUG_RENDERER)
+extern bool g_HWUI_DEBUG_SHADOW;
+
+// debug dump functions
+extern bool g_HWUI_debug_dumpDisplayList;
+extern bool g_HWUI_debug_dumpDraw;
+extern bool g_HWUI_debug_dumpTexture;
+extern bool g_HWUI_debug_dumpAlphaTexture;
+extern bool g_HWUI_debug_dumpLayer;
+extern bool g_HWUI_debug_dumpTextureLayer;
+
+// sync with egl trace
+extern bool g_HWUI_debug_egl_trace;
+
+// misc
+extern bool g_HWUI_debug_enhancement;
+extern bool g_HWUI_debug_continuous_frame;
+extern bool g_HWUI_debug_record_state;
+extern bool g_HWUI_debug_systrace;
+extern bool g_HWUI_debug_hwuitask;
+
+extern void setDebugLog();
+
+///////////////////////////////////////////////////////////////////////////////
+// Defines
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef ATRACE_TAG_HWUI
+#define ATRACE_TAG_HWUI ATRACE_TAG_VIEW
+#endif
+
+/**
+ * Log helper
+ */
+#define MLOGD(OPTION, ...) if (CC_UNLIKELY(g_HWUI_##OPTION)) ALOGD(__VA_ARGS__)
+
+/**
+ * Systrace helper
+ */
+// overview
+#define ATRACE_BEGIN_L1(...) atrace_begin(ATRACE_TAG_VIEW, __VA_ARGS__)
+#define ATRACE_END_L1() atrace_end(ATRACE_TAG_VIEW)
+#define ATRACE_NAME_L1(...) android::ScopedTrace ___tracer(ATRACE_TAG_VIEW, __VA_ARGS__)
+#define ATRACE_CALL_L1() ATRACE_NAME_L1(__FUNCTION__)
+#define ATRACE_FORMAT_L1(fmt, ...) \
+        HwuiTraceUtils::HwuiTraceEnder __traceEnder = \
+        (HwuiTraceUtils::atraceFormatBegin(ATRACE_TAG_VIEW, true, fmt, ##__VA_ARGS__), \
+        HwuiTraceUtils::HwuiTraceEnder(ATRACE_TAG_VIEW, true))
+#define ATRACE_FORMAT_BEGIN_L1(fmt, ...) \
+        HwuiTraceUtils::atraceFormatBegin(ATRACE_TAG_VIEW, true, fmt, ##__VA_ARGS__)
+
+// detail
+#define ATRACE_BEGIN_L2(...) atrace_begin(ATRACE_TAG_HWUI, __VA_ARGS__)
+#define ATRACE_END_L2() atrace_end(ATRACE_TAG_HWUI)
+#define ATRACE_NAME_L2(...) android::ScopedTrace ___tracer(ATRACE_TAG_HWUI, __VA_ARGS__)
+#define ATRACE_CALL_L2() ATRACE_NAME_L2(__FUNCTION__)
+#define ATRACE_FORMAT_L2(fmt, ...) \
+        HwuiTraceUtils::HwuiTraceEnder __traceEnder = \
+        (HwuiTraceUtils::atraceFormatBegin(ATRACE_TAG_HWUI, true, fmt, ##__VA_ARGS__), \
+        HwuiTraceUtils::HwuiTraceEnder(ATRACE_TAG_HWUI, true))
+#define ATRACE_FORMAT_BEGIN_L2(fmt, ...) \
+        HwuiTraceUtils::atraceFormatBegin(ATRACE_TAG_HWUI, true, fmt, ##__VA_ARGS__)
+
+// more detail
+#define ATRACE_BEGIN_L3(...) if (CC_UNLIKELY(g_HWUI_debug_systrace)) atrace_begin(ATRACE_TAG_HWUI, __VA_ARGS__)
+#define ATRACE_END_L3() if (CC_UNLIKELY(g_HWUI_debug_systrace)) atrace_end(ATRACE_TAG_HWUI)
+#define ATRACE_NAME_L3(...) HwuiScopedTrace ___tracer(__VA_ARGS__)
+#define ATRACE_CALL_L3() ATRACE_NAME_L3(__FUNCTION__)
+#define ATRACE_FORMAT_L3(fmt, ...) \
+        HwuiTraceUtils::HwuiTraceEnder __traceEnder = \
+        (HwuiTraceUtils::atraceFormatBegin(ATRACE_TAG_HWUI, false, fmt, ##__VA_ARGS__), \
+        HwuiTraceUtils::HwuiTraceEnder(ATRACE_TAG_HWUI, false))
+#define ATRACE_FORMAT_BEGIN_L3(fmt, ...) \
+        HwuiTraceUtils::atraceFormatBegin(ATRACE_TAG_HWUI, false, fmt, ##__VA_ARGS__)
+
+/**
+ * Performance log helper
+ */
+#define TIME_LOG_NAME(NAME) ScopedMonitor __monitor = ScopedMonitor(NAME, nullptr)
+
+#define TIME_LOG_BASIC(NAME, COMMAND) \
+        {   \
+            TIME_LOG_NAME(NAME); \
+            COMMAND; \
+        }
+
+#define TIME_LOG_SYSTRACE(NAME, COMMAND, SYSTRACE_NAME) \
+            ATRACE_BEGIN_L2(SYSTRACE_NAME); TIME_LOG_BASIC(NAME, COMMAND); ATRACE_END_L2()
+
+#define TIME_LOG(NAME, COMMAND) TIME_LOG_SYSTRACE(NAME, COMMAND, NAME)
+
+/**
+ * Dump helper
+ */
+#define IF_METHOD(CONDITION, INSTANCE, FUNCTION, ...) \
+        if (CC_UNLIKELY(CONDITION)) { \
+            INSTANCE::getInstance().FUNCTION(__VA_ARGS__); \
+        }
+
+#define DUMP_DISPLAY_LIST(...) IF_METHOD(g_HWUI_debug_dumpDisplayList, Dumper, dumpDisplayList, __VA_ARGS__)
+#define DUMP_DRAW(...) IF_METHOD(g_HWUI_debug_dumpDraw, Dumper, dumpDraw, __VA_ARGS__)
+#define DUMP_TEXTURE(...) IF_METHOD(g_HWUI_debug_dumpTexture,Dumper, dumpTexture, __VA_ARGS__, false)
+#define DUMP_ALPHA_TEXTURE(...) IF_METHOD(g_HWUI_debug_dumpAlphaTexture, Dumper, dumpAlphaTexture, __VA_ARGS__)
+#define DUMP_LAYER(...) IF_METHOD(g_HWUI_debug_dumpLayer, Dumper, dumpLayer, __VA_ARGS__)
+#define DUMP_TEXTURE_LAYER(...) IF_METHOD(g_HWUI_debug_dumpTextureLayer, Dumper, dumpTexture, __VA_ARGS__, true)
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes
+///////////////////////////////////////////////////////////////////////////////
+
+class HwuiTraceUtils {
+public:
+    class HwuiTraceEnder {
+    public:
+        HwuiTraceEnder(int tag, bool force) : mTag(tag), mForce(force) { }
+        ~HwuiTraceEnder() {
+            if (CC_UNLIKELY(ATRACE_ENABLED()) &&
+                    (mForce || CC_UNLIKELY(g_HWUI_debug_systrace))) {
+                atrace_end(mTag);
+            }
+        }
+    private:
+        int mTag;
+        bool mForce;
+    };
+
+    static void atraceFormatBegin(int tag, bool force, const char* fmt, ...) {
+        if (CC_UNLIKELY(ATRACE_ENABLED()) &&
+                (force || CC_UNLIKELY(g_HWUI_debug_systrace))) {
+            const int BUFFER_SIZE = 256;
+            va_list ap;
+            char buf[BUFFER_SIZE];
+
+            va_start(ap, fmt);
+            vsnprintf(buf, BUFFER_SIZE, fmt, ap);
+            va_end(ap);
+
+            atrace_begin(tag, buf);
+        }
+    }
+};
+
+class HwuiScopedTrace {
+public:
+    inline HwuiScopedTrace(const char* name) {
+        if (g_HWUI_debug_systrace) atrace_begin(ATRACE_TAG_HWUI, name);
+    }
+
+    inline ~HwuiScopedTrace() {
+        if (g_HWUI_debug_systrace) atrace_end(ATRACE_TAG_HWUI);
+    }
+};
+
+class ScopedMonitor {
+public:
+    inline ScopedMonitor(const char* name, nsecs_t* duration) {
+#ifdef MTK_DEBUG_RENDERER
+        mTask = new MonitorTask(name);
+        mDurationNs = duration;
+#endif
+    }
+
+    inline ~ScopedMonitor() {
+#ifdef MTK_DEBUG_RENDERER
+        // task will commit suicide
+        nsecs_t duration = mTask->requestRemove();
+        if (mDurationNs) *mDurationNs = duration;
+#endif
+    }
+private:
+#ifdef MTK_DEBUG_RENDERER
+    MonitorTask* mTask;
+    nsecs_t* mDurationNs;
+#endif
+};
+
+}; // namespace uirenderer
+}; // namespace android
+
+#endif /* MTK_HWUI_DEBUG_H */
diff --git a/libs/hwui/mediatek/MTKDumper.cpp b/libs/hwui/mediatek/MTKDumper.cpp
new file mode 100644
index 0000000..bbbba99
--- /dev/null
+++ b/libs/hwui/mediatek/MTKDumper.cpp
@@ -0,0 +1,437 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+#include "MTKDumper.h"
+#include "../OpenGLRenderer.h"
+
+#include <GLES3/gl3.h>
+#include <SkCanvas.h>
+#include <SkImageEncoder.h>
+#include <utils/String8.h>
+#include <utils/Trace.h>
+
+
+namespace android {
+
+using namespace uirenderer;
+ANDROID_SINGLETON_STATIC_INSTANCE(Dumper);
+
+namespace uirenderer {
+
+#define MAX_BUFFER_SIZE 64 * 1048576 // max 64MB for all threads
+#define TARGET_SIZE 102480.f // 240 * 427
+
+///////////////////////////////////////////////////////////////////////////////
+// DumpBarrier
+///////////////////////////////////////////////////////////////////////////////
+
+class DumpBarrier {
+    public:
+        DumpBarrier(Condition::WakeUpType type = Condition::WAKE_UP_ALL) : mType(type), mSignaled(false) { }
+        ~DumpBarrier() { }
+
+        void signal() {
+            Mutex::Autolock l(mLock);
+            mSignaled = true;
+            mCondition.signal(mType);
+        }
+
+        void wait() {
+            Mutex::Autolock l(mLock);
+            while (!mSignaled) {
+                mCondition.wait(mLock);
+            }
+            mSignaled = false;
+        }
+
+    private:
+        Condition::WakeUpType mType;
+        volatile bool mSignaled;
+        mutable Mutex mLock;
+        mutable Condition mCondition;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// DumpTask
+///////////////////////////////////////////////////////////////////////////////
+
+class DumpTask {
+public:
+    DumpTask(int w, int h, const char* f, bool c):
+        width(w), height(h), size(width * height * 4), compress(c), flip(true) {
+        memcpy(filename, f, 512);
+        bitmap.setInfo(SkImageInfo::MakeN32Premul(width, height));
+        bitmap.allocPixels();
+    }
+
+    DumpTask(const SkBitmap* b, const char* f, bool c):
+        width(b->width()), height(b->height()), size(b->getSize()), compress(c), flip(false) {
+        memcpy(filename, f, 512);
+
+        nsecs_t start = systemTime(SYSTEM_TIME_MONOTONIC);
+        b->copyTo(&bitmap, kN32_SkColorType);
+        nsecs_t end = systemTime(SYSTEM_TIME_MONOTONIC);
+        ALOGD("copyTo %dx%d, time %" PRId64 "ms", width, height, nanoseconds_to_milliseconds(end - start));
+    }
+
+    ~DumpTask() {
+    }
+
+    void preProcess() {
+        // for ARGB only
+        if (bitmap.readyToDraw() && compress) {
+            nsecs_t start = systemTime(SYSTEM_TIME_MONOTONIC);
+            float ratio = sqrt(TARGET_SIZE / width / height) ;
+
+            if (ratio < 1) {
+                int w = (int)(width * ratio + 0.5);;
+                int h = (int)(height * ratio + 0.5);
+                SkBitmap dst;
+                dst.setInfo(SkImageInfo::MakeN32Premul(w, h));
+                dst.allocPixels();
+                dst.eraseColor(0);
+
+                SkPaint paint;
+                SkCanvas canvas(dst);
+                canvas.scale(ratio, ratio);
+                canvas.drawBitmap(bitmap, 0.0f, 0.0f, &paint);
+                dst.copyTo(&bitmap, kN32_SkColorType);
+                nsecs_t end = systemTime(SYSTEM_TIME_MONOTONIC);
+                ALOGD("scale ratio %f, %dx%d, time %" PRId64 "ms",
+                    ratio, bitmap.width(), bitmap.height(), nanoseconds_to_milliseconds(end - start));
+            } else {
+                ALOGD("scale ratio %f >= 1, %dx%d not needed", ratio, bitmap.width(), bitmap.height());
+            }
+
+        }
+    }
+
+    void onProcess() {
+        nsecs_t start = systemTime(SYSTEM_TIME_MONOTONIC);
+        if (flip) {
+            SkBitmap dst;
+            dst.setInfo(SkImageInfo::MakeN32Premul(bitmap.width(), bitmap.height()));
+            dst.allocPixels();
+            dst.eraseColor(0);
+
+            SkPaint paint;
+            SkCanvas canvas(dst);
+            canvas.scale(1.0f, -1.0f);
+            canvas.translate(0.0f, -bitmap.height());
+            canvas.drawBitmap(bitmap, 0.0f, 0.0f, &paint);
+            dst.copyTo(&bitmap, kN32_SkColorType);
+        }
+        if (!SkImageEncoder::EncodeFile(filename, bitmap, SkImageEncoder::kPNG_Type, quality)) {
+            ALOGE("Failed to encode image %s\n", filename);
+            char* lastPeriod = strrchr(filename, '/');
+            if (lastPeriod) {
+                char file[512];
+                // folder /data/HWUI_dump/ will be created by script
+                sprintf(file, "/data/HWUI_dump/%s", lastPeriod + 1);
+                if (!SkImageEncoder::EncodeFile(file, bitmap, SkImageEncoder::kPNG_Type, quality)) {
+                    ALOGE("Failed to encode image %s\n", file);
+                }
+            }
+        }
+        nsecs_t end = systemTime(SYSTEM_TIME_MONOTONIC);
+        ALOGD("encodeFile %dx%d, time %" PRId64 "ms",
+            bitmap.width(), bitmap.height(), nanoseconds_to_milliseconds(end - start));
+    }
+
+    int width;
+    int height;
+    size_t size;
+    char filename[512];
+    SkBitmap bitmap;
+    bool compress;
+    bool flip;
+    int quality = 60;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// DumperThread
+///////////////////////////////////////////////////////////////////////////////
+
+class DumperThread: public Thread {
+public:
+     DumperThread(const String8 name): mSignal(Condition::WAKE_UP_ONE), mName(name) { }
+
+     bool addTask(DumpTask *task) {
+         if (!isRunning()) {
+             run(mName.string(), PRIORITY_DEFAULT);
+         }
+
+         Mutex::Autolock l(mLock);
+         ssize_t index = mTasks.add(task);
+         mSignal.signal();
+
+         return index >= 0;
+     }
+     size_t getTaskCount() const {
+         Mutex::Autolock l(mLock);
+         return mTasks.size();
+     }
+     void exit() {
+         {
+             Mutex::Autolock l(mLock);
+             for (size_t i = 0; i < mTasks.size(); i++) {
+                 const DumpTask* task = mTasks.itemAt(i);
+                 delete task;
+             }
+             mTasks.clear();
+         }
+         requestExit();
+         mSignal.signal();
+     }
+
+ private:
+     virtual bool threadLoop() {
+         mSignal.wait();
+         Vector<DumpTask*> tasks;
+         {
+             Mutex::Autolock l(mLock);
+             tasks = mTasks;
+             mTasks.clear();
+         }
+
+         for (size_t i = 0; i < tasks.size(); i++) {
+             DumpTask* task = tasks.itemAt(i);
+             task->onProcess();
+             delete task;
+         }
+         return true;
+     }
+
+     // Lock for the list of tasks
+     mutable Mutex mLock;
+     Vector<DumpTask *> mTasks;
+
+     // Signal used to wake up the thread when a new
+     // task is available in the list
+     mutable DumpBarrier mSignal;
+
+     const String8 mName;
+ };
+
+///////////////////////////////////////////////////////////////////////////////
+// Dumper
+///////////////////////////////////////////////////////////////////////////////
+
+Dumper::Dumper() : mPid(getpid())
+                 , mProcessName(nullptr)
+                 , mThreadCount(sysconf(_SC_NPROCESSORS_CONF) / 2) {
+    // Get the number of available CPUs. This value does not change over time.
+    ALOGD("Dumper init %d threads <%p>", mThreadCount, this);
+    for (int i = 0; i < mThreadCount; i++) {
+        String8 name;
+        name.appendFormat("HwuiDumperThread%d", i + 1);
+        mThreads.add(new DumperThread(name));
+    }
+
+    // Get process name
+    FILE *f;
+    char processName[256];
+    bool success = true;
+
+    f = fopen("/proc/self/cmdline", "r");
+    if (!f) {
+        ALOGE("Can't get application name");
+        success = false;
+    } else {
+        if (fgets(processName, 256, f) == nullptr) {
+            ALOGE("fgets failed");
+            success = false;
+        }
+        fclose(f);
+    }
+
+    if (success) {
+        mProcessName = new char[strlen(processName) + 1];
+        memmove(mProcessName, processName, strlen(processName) + 1);
+        ALOGD("<%s> is running.", mProcessName);
+    }
+}
+
+Dumper::~Dumper() {
+    for (size_t i = 0; i < mThreads.size(); i++) {
+        mThreads[i]->exit();
+    }
+    if (mProcessName) {
+        delete []mProcessName;
+        mProcessName = nullptr;
+    }
+}
+
+bool Dumper::addTask(DumpTask *task) {
+    task->preProcess();
+    if (mThreads.size() > 0) {
+        size_t minQueueSize = MAX_BUFFER_SIZE / mThreadCount / task->bitmap.getSize();
+        sp<DumperThread> thread;
+        for (size_t i = 0; i < mThreads.size(); i++) {
+            if (mThreads[i]->getTaskCount() < minQueueSize) {
+                thread = mThreads[i];
+                minQueueSize = mThreads[i]->getTaskCount();
+            }
+        }
+
+        if (thread.get() == nullptr)
+            return false;
+
+        return thread->addTask(task);
+    }
+    return false;
+}
+
+bool Dumper::dumpDisplayList(int width, int height, const char* name,
+    int frameCount, void* renderer) {
+    char file[512];
+    sprintf(file, "/data/data/%s/dp_%p_%09d.png", mProcessName, renderer, frameCount);
+
+    ALOGD("%s [%s]: %dx%d %s", __FUNCTION__, name, width, height, file);
+    return dumpImage(width, height, file);
+}
+
+bool Dumper::dumpDraw(int width, int height, int frameCount, int index,
+        void* renderer, void* drawOp, int sub) {
+    char file[512];
+    sprintf(file, "/data/data/%s/draw_%p_%09d_%02d_%02d_%p.png",
+        mProcessName, renderer, frameCount, index, sub, drawOp);
+
+    ALOGD("%s: %dx%d %s", __FUNCTION__, width, height, file);
+    return dumpImage(width, height, file);
+}
+
+bool Dumper::dumpLayer(int width, int height, int fbo, int frameCount,
+        void* renderer, void* layer) {
+    char file[512];
+    nsecs_t time = systemTime(SYSTEM_TIME_MONOTONIC);
+    sprintf(file, "/data/data/%s/layer_%p_%p_%d_%dx%d_%09d_%09u.png",
+        mProcessName, renderer, layer, fbo, width, height, frameCount, (unsigned int) time / 1000);
+
+    ALOGD("%s: %dx%d %s", __FUNCTION__, width, height, file);
+    return dumpImage(width, height, file);
+}
+
+bool Dumper::dumpTexture(int texture, int width, int height, const SkBitmap *bitmap, bool isLayer) {
+    char file[512];
+
+    if (isLayer) {
+        nsecs_t time = systemTime(SYSTEM_TIME_MONOTONIC);
+        sprintf(file, "/data/data/%s/texLayer_%d_%dx%d_%u.png",
+            mProcessName, texture, width, height, (unsigned int) time / 1000);
+    } else {
+        sprintf(file, "/data/data/%s/tex_%d_%dx%d_%p.png",
+            mProcessName, texture, width, height, bitmap);
+    }
+
+    ALOGD("%s: %dx%d %s", __FUNCTION__, width, height, file);
+
+    DumpTask* task = new DumpTask(bitmap, file, isLayer);
+    if (!task->bitmap.readyToDraw()) {
+        ALOGE("%s: failed to copy bitmap %p\n", __FUNCTION__, bitmap);
+        delete task;
+        return false;
+    }
+
+    if (addTask(task)) {
+        // dumper will help to delete task when task finished
+    } else {
+        task->onProcess();
+        delete task;
+    }
+
+    return true;
+}
+
+bool Dumper::dumpAlphaTexture(int width, int height, uint8_t *data, const char *prefix, bool isA8) {
+    static int count = 0;
+
+    char file[512];
+    SkBitmap bitmap;
+    SkBitmap bitmapCopy;
+
+    sprintf(file, "/data/data/%s/%s_%04d.png", mProcessName, prefix, count++);
+
+    ALOGD("%s: %dx%d %s", __FUNCTION__, width, height, file);
+    if (isA8)
+        bitmap.setInfo(SkImageInfo::MakeA8(width, height));
+    else
+        bitmap.setInfo(SkImageInfo::MakeN32Premul(width, height));
+    bitmap.setPixels(data, nullptr);
+
+    DumpTask* task = new DumpTask(&bitmap, file, false);
+
+    if (!task->bitmap.readyToDraw()) {
+        ALOGE("%s: failed to copy data %p", __FUNCTION__, data);
+        delete task;
+        return false;
+    }
+
+    // dump directlly because pixelbuffer becomes invalid if using multi-thread
+    task->onProcess();
+    delete task;
+
+    return true;
+}
+
+bool Dumper::dumpImage(int width, int height, const char *filename) {
+    DumpTask* task = new DumpTask(width, height, filename, true);
+    GLenum error;
+    nsecs_t start = systemTime(SYSTEM_TIME_MONOTONIC);
+    glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, task->bitmap.getPixels());
+    nsecs_t end = systemTime(SYSTEM_TIME_MONOTONIC);
+    ALOGD("%s: readpixel %dx%d time %" PRId64 "ms",
+        __FUNCTION__, width, height, nanoseconds_to_milliseconds(end - start));
+
+    if ((error = glGetError()) != GL_NO_ERROR) {
+        ALOGE("%s: get GL error 0x%x \n", __FUNCTION__, error);
+        delete task;
+        return false;
+    }
+
+    if (addTask(task)) {
+        // dumper will help to delete task when task finished
+    } else {
+        task->onProcess();
+        delete task;
+    }
+
+    return true;
+}
+
+}; // namespace uirenderer
+}; // namespace android
diff --git a/libs/hwui/mediatek/MTKDumper.h b/libs/hwui/mediatek/MTKDumper.h
new file mode 100644
index 0000000..2de3c44
--- /dev/null
+++ b/libs/hwui/mediatek/MTKDumper.h
@@ -0,0 +1,84 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+#ifndef MTK_HWUI_DUMPER_H
+#define MTK_HWUI_DUMPER_H
+
+#include <utils/Singleton.h>
+#include <utils/Vector.h>
+#include <SkBitmap.h>
+
+namespace android {
+namespace uirenderer {
+
+///////////////////////////////////////////////////////////////////////////////
+// Dumper
+///////////////////////////////////////////////////////////////////////////////
+class DumpBarrier;
+class DumpTask;
+class DumperThread;
+class OpenGLRenderer;
+
+class Dumper: public Singleton<Dumper> {
+    friend class Singleton<Dumper>;
+public:
+    Dumper();
+    ~Dumper();
+
+    int mPid;
+    char* mProcessName;
+
+public:
+    bool addTask(DumpTask* task);
+    bool dumpDisplayList(int width, int height, const char* name, int frameCount, void* renderer);
+    bool dumpDraw(int width, int height, int frameCount,
+        int index, void* renderer, void* drawOp, int sub = 0);
+    bool dumpLayer(int width, int height, int fbo,
+        int frameCount, void* renderer, void* layer);
+    bool dumpTexture(int texture, int width, int height, const SkBitmap* bitmap, bool isLayer);
+    bool dumpAlphaTexture(int width, int height, uint8_t* data, const char* prefix, bool isA8 = true);
+
+private:
+    bool dumpImage(int width, int height, const char *filename);
+    int mThreadCount;
+    Vector<sp<DumperThread> > mThreads;
+};
+
+}; // namespace uirenderer
+}; // namespace android
+
+#endif /* MTK_HWUI_DUMPER_H */
diff --git a/libs/hwui/mediatek/MTKMonitorThread.h b/libs/hwui/mediatek/MTKMonitorThread.h
new file mode 100644
index 0000000..d1f19d8
--- /dev/null
+++ b/libs/hwui/mediatek/MTKMonitorThread.h
@@ -0,0 +1,183 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+#ifndef MTK_HWUI_MONITOR_H
+#define MTK_HWUI_MONITOR_H
+
+#include <utils/Singleton.h>
+#include <utils/threads.h>
+#include <stdint.h>
+#include <sys/types.h>
+
+namespace android {
+namespace uirenderer {
+
+class MonitorThread;
+class MonitorTask;
+class MonitorQueue;
+
+/*
+ * MonitorThread helps to supervise the execution time of a job (e.g. RenderTask)
+ * Queue a monitor task before running your job and remove it after the job's finished.
+ * If the job runs too long, for example, more than 500ms, MonitorThread will keep
+ * notifying to warn you until it's done.
+ */
+
+///////////////////////////////////////////////////////////////////////////////
+// MonitorSignal
+///////////////////////////////////////////////////////////////////////////////
+
+class MonitorSignal {
+public:
+    MonitorSignal(Condition::WakeUpType type = Condition::WAKE_UP_ALL) : mType(type) { }
+    ~MonitorSignal() { }
+
+    void signal() {
+        mCondition.signal(mType);
+    }
+
+    void wait(int reltimeMs) {
+        Mutex::Autolock l(mLock);
+        if (reltimeMs > 0) {
+            mCondition.waitRelative(mLock, milliseconds_to_nanoseconds(reltimeMs));
+        } else if (reltimeMs < 0){
+            mCondition.wait(mLock);
+        }
+    }
+
+private:
+    Condition::WakeUpType mType;
+    mutable Mutex mLock;
+    mutable Condition mCondition;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// MonitorTask
+///////////////////////////////////////////////////////////////////////////////
+
+class MonitorTask {
+    friend class MonitorThread;
+    friend class MonitorQueue;
+public:
+    MonitorTask(const char* label);
+
+    // request to remove and return the total executation time of the task,
+    // it may have deleted itself, do not reference it again
+    nsecs_t requestRemove();
+
+private:
+    void run();
+
+    // nano-seconds on the SYSTEM_TIME_MONOTONIC clock
+    // start: when the task is added to montor thread
+    // run: when the task is run in monitor thread
+    // end: when the task is removed from monitor thread.
+    nsecs_t mStartAt;
+    nsecs_t mRunAt;
+    nsecs_t mEndAt;
+
+    // label to indicate this task is for what job
+    const char* mLabel;
+    MonitorTask* mNext;
+    MonitorThread& mMonitorThread;
+    bool mRequestRemove;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// MonitorQueue
+///////////////////////////////////////////////////////////////////////////////
+
+class MonitorQueue {
+    friend class MonitorThread;
+public:
+    MonitorQueue() : mHead(nullptr), mTail(nullptr) { }
+
+    MonitorTask* next();
+    void queue(MonitorTask* task);
+    MonitorTask* peek();
+    void remove(MonitorTask* task);
+
+private:
+    MonitorTask* mHead;
+    MonitorTask* mTail;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// MonitorThread
+///////////////////////////////////////////////////////////////////////////////
+
+class MonitorThread: public Thread, public Singleton<MonitorThread> {
+    friend class MonitorTask;
+public:
+    MonitorThread();
+    friend class Singleton<MonitorThread>;
+
+public:
+    // dump all task for debug purposes
+    void dump(FILE* file = nullptr);
+
+protected:
+    virtual bool threadLoop() override;
+
+private:
+    // keep all operation as private, only MonitorTask can use
+
+    // queue a task to monitor thread
+    void queue(MonitorTask* task);
+    void queueLocked(MonitorTask* task);
+
+    // remove a task and return the total executation time of the task
+    nsecs_t remove(MonitorTask* task);
+
+    // Returns the next task to be run. If this returns NULL nextWakeup is set
+    // to the time to requery for the nextTask to run. mNextWakeup is also
+    // set to this time
+    MonitorTask* nextTask(nsecs_t* nextWakeup);
+
+    Mutex mLock;
+    nsecs_t mNextWakeup;
+    MonitorQueue mQueue;
+
+    // Signal used to wake up the thread when a new
+    // task is available in the list
+    mutable MonitorSignal mSignal;
+};
+
+}; // namespace uirenderer
+}; // namespace android
+
+#endif /* MTK_HWUI_MONITORTHREAD_H */
diff --git a/libs/hwui/mediatek/MTKProgramAtlas.cpp b/libs/hwui/mediatek/MTKProgramAtlas.cpp
new file mode 100644
index 0000000..d474178
--- /dev/null
+++ b/libs/hwui/mediatek/MTKProgramAtlas.cpp
@@ -0,0 +1,216 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/// M: used for program binary
+#include <cutils/ashmem.h>
+#include <sys/mman.h>
+
+#include <binder/IPCThreadState.h>
+#include <binder/ProcessState.h>
+#include <binder/IServiceManager.h>
+#include <utils/Log.h>
+#include <fcntl.h>
+
+#include "MTKProgramAtlas.h"
+#include "IProgramBinaryService.h"
+#include "ProgramBinaryData.h"
+#include "../Extensions.h"
+#include "../ProgramCache.h"
+
+#include <unistd.h>
+
+namespace android {
+namespace uirenderer {
+
+void ProgramAtlas::init() {
+    if (mProgramBinaries) {
+        ALOGI("Already had program atlas...");
+        return;
+    }
+
+    /// M: Check whether program binary service is enabled or not.
+    char propertyDisable[PROPERTY_VALUE_MAX] = {0};
+    if (property_get(PROPERTY_DISABLE_PROGRAM_BINARY, propertyDisable, "0") > 0) {
+        ALOGI("Get disable program binary service property (%s)", propertyDisable);
+        mEnableProgramBinaryService = !atoi(propertyDisable);
+    }
+
+    if (!mEnableProgramBinaryService) {
+        ALOGW("Program binary service is disabled.");
+        return;
+    }
+
+    ALOGI("Initializing program atlas...");
+
+    /// M: Get program binary service
+    sp<android::IServiceManager> sm = defaultServiceManager();
+    sp<android::IBinder> binder;
+    sp<IProgramBinaryService> pbs;
+
+    binder = sm->checkService(String16(PROGRAM_BINARY_NAME));
+    if (binder == 0) {
+        ALOGW("Program binary service not published, failed to get program binary.");
+        mProgramBinaries = NULL;
+        return;
+    }
+
+    /// M: Get program binary content through binder
+    pbs = interface_cast<IProgramBinaryService>(binder);
+    int fd = -1;
+    int programMapLen = 0;
+    if (pbs->getReady()) {
+        ProgramBinaryData* pbData = pbs->getProgramBinaryData();
+        fd = pbData->getFileDescriptor();
+        mProgramLength = pbData->getProgramBinaryLen();
+        programMapLen = pbData->getProgramMapLen();
+        pbData->getProgramMapArray(&mProgramMap);
+        delete pbData;
+        ALOGI("Program binary detail: Binary length is %d, program map length is %d.",
+                mProgramLength, programMapLen);
+    }
+
+    if (fd < 0 || programMapLen <= 0 || mProgramMap == NULL || mProgramLength <= 0) {
+        ALOGW("Program binary service is not ready.");
+        return;
+    }
+
+    // M: mmap the shared memory to this process.
+    int64_t result = (int64_t)mmap(NULL, mProgramLength, PROT_READ, MAP_SHARED, fd, 0);
+    if (result == (int64_t)MAP_FAILED) {
+        ALOGW("Failed to mmap program binaries. File descriptor is %d, error code is %d, and status is %d", fd, errno, fcntl(fd, F_GETFL));
+        return;
+    } else {
+        /// M: Show file descriptor and mapped path
+        char s[256] = {0};
+        char name[256] = {0};
+        snprintf(s, 255, "/proc/%d/fd/%d", getpid(), fd);
+        int len = readlink(s, name, sizeof(name) - 1);
+        if (CC_UNLIKELY(len < 0)) {
+            ALOGE("Program atlas init, failed to readlink.");
+        }
+
+        ALOGI("Succeeded to mmap program binaries. File descriptor is %d, and path is %s.", fd, name);
+
+        mProgramBinaries = (void*) result;
+    }
+
+    if (mProgramBinaries && mProgramMap) {
+        /// M: program binary entries
+        for (int i = 0; i < programMapLen; ) {
+            programid key = static_cast<programid>(mProgramMap[i++]);
+            int binaryOffset = mProgramMap[i++];
+            void* binary = reinterpret_cast<void*>(reinterpret_cast<int64_t>(mProgramBinaries) + binaryOffset);
+            GLint length = static_cast<GLint>(mProgramMap[i++]);
+            GLenum format = static_cast<GLenum>(mProgramMap[i++]);
+            ProgramEntry* entry = new ProgramEntry(key, binary, length, format);
+            /// M: Don't add duplicate program entry into cache in case of memory leak.
+            if (mProgramEntries.indexOfKey(key) < 0) {
+                mProgramEntries.add(entry->programKey, entry);
+            } else {
+                PROGRAM_LOGD("ProgramEntry #%2d: key 0x%.8x%.8x is duplicated!",
+                    i/4, uint32_t(key >> 32), uint32_t(key & 0xffffffff));
+                continue;
+            }
+
+            char* ubinary = 0;
+            ubinary = static_cast<char*>(binary);
+            PROGRAM_LOGD("ProgramEntry #%2d: key 0x%.8x%.8x, offset %6d, binaryLength %4d, format %d --> 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x",
+                i/4, uint32_t(key >> 32), uint32_t(key & 0xffffffff), binaryOffset, length, format,
+                ubinary[0], ubinary[1], ubinary[2], ubinary[3], ubinary[4], ubinary[5], ubinary[6], ubinary[7], ubinary[8], ubinary[9]);
+        }
+        /// M: Close file descriptor.
+        if (fd >=0) {
+            ALOGI("No need to use file discriptor anymore, close fd(%d).", fd);
+            close(fd);
+        }
+        /// M: mPorgramEntries is ready, set initialized to true for later usage.
+        mPorgramEntriesInitialized = true;
+    } else {
+        ALOGI("Failed to setup program atlas.");
+        mProgramLength = 0;
+        mProgramBinaries = NULL;
+        mProgramMap = NULL;
+    }
+}
+
+/// M: get the entry of each program binary
+ProgramAtlas::ProgramEntry* ProgramAtlas::getProgramEntry(programid key) {
+    if (!mPorgramEntriesInitialized) {
+        /// M: mPorgramEntries is not properly intialized.
+        return NULL;
+    }
+
+    ssize_t index = mProgramEntries.indexOfKey(key);
+    return index >= 0 ? mProgramEntries.valueAt(index) : NULL;
+}
+
+void ProgramAtlas::terminate() {
+    if (mProgramBinaries) {
+        /// M: unmap address if using program binaries is enabled
+        int64_t result = munmap(mProgramBinaries, mProgramLength);
+        if (result < 0) ALOGW("Failed to munmap program binaries.");
+
+        delete mProgramMap;
+        mProgramBinaries = NULL;
+        mProgramLength = 0;
+        mProgramMap = NULL;
+
+        /// M: Clear program entries
+        for (size_t i = 0; i < mProgramEntries.size(); i++) {
+            delete mProgramEntries.valueAt(i);
+        }
+        mProgramEntries.clear();
+        mPorgramEntriesInitialized = false;
+    }
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// M: [ProgramBinaryAtlas] Program atlas enhancement
+///////////////////////////////////////////////////////////////////////////////
+
+int ProgramAtlas::createPrograms(int64_t* map, int* mapLength) {
+    Extensions extensions;
+    ProgramCache cache(extensions);
+    return 0;  // cache.createPrograms(map, mapLength);
+}
+
+// void ProgramAtlas::loadProgramBinariesAndDelete(int64_t* map, int mapLength, void* buffer, int length) {
+//    ProgramCache::loadProgramBinariesAndDelete(map, mapLength, buffer, length);
+
+}; // namespace uirenderer
+}; // namespace android
+
diff --git a/libs/hwui/mediatek/MTKProgramAtlas.h b/libs/hwui/mediatek/MTKProgramAtlas.h
new file mode 100644
index 0000000..01e1bff
--- /dev/null
+++ b/libs/hwui/mediatek/MTKProgramAtlas.h
@@ -0,0 +1,130 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+#ifndef ANDROID_HWUI_PROGRAM_ATLAS_H
+#define ANDROID_HWUI_PROGRAM_ATLAS_H
+
+#include <GLES2/gl2.h>
+
+#include <utils/KeyedVector.h>
+
+#include "../Program.h"
+
+namespace android {
+namespace uirenderer {
+
+/**
+ *
+ */
+class ProgramAtlas {
+public:
+    /**
+     * M: ProgramEntry representing the program binary inside the atlas.
+     */
+    struct ProgramEntry {
+        programid programKey;
+        void* binary;
+        GLint   binaryLength;
+        GLenum  binaryFormat;
+
+    private:
+        ProgramEntry(programid key, void* b, GLint length, GLenum format):
+                programKey(key), binary(b), binaryLength(length), binaryFormat(format) {
+        }
+
+        ~ProgramEntry() {
+        }
+
+        friend class ProgramAtlas;
+    };
+
+    ProgramAtlas(): mProgramBinaries(NULL), mProgramLength(0), mProgramMap(NULL),
+            mEnableProgramBinaryService(false), mPorgramEntriesInitialized(false) { }
+    ~ProgramAtlas() {terminate(); }
+
+    /**
+     * M: Initialize program atlas.
+     */
+    void init();
+
+    /**
+     * M: Get the entry of each program binary.
+     */
+    ProgramEntry* getProgramEntry(programid key);
+
+    /**
+     *
+     */
+    ANDROID_API void terminate();
+
+    /**
+     * M: [ProgramBinaryAtlas] Create program and its mapping table, return the total memory size
+     * for caching programs binaries, and update the correct mapLength.
+     *
+     * The mapping will be ProgramKey, Offset, Length, "ProgramId", ProgramKey, Offset...
+     */
+    ANDROID_API int createPrograms(int64_t* map, int* mapLength);
+
+    /**
+     * M: [ProgramBinaryAtlas] Load program binaries to the buffer, delete programs, and update the map
+     *
+     * The mapping will be ProgramKey, Offset, Length, "Format", ProgramKey, Offset...
+     */
+    ANDROID_API void loadProgramBinariesAndDelete(int64_t* map, int mapLength, void* buffer, int length);
+
+    /**
+     * M: check whether the program binary service is enabled
+     */
+    bool getServiceEnabled() { return mEnableProgramBinaryService; };
+
+private:
+    /// M: Used to munmap program binaries
+    void* mProgramBinaries;
+    int mProgramLength;
+    int64_t* mProgramMap;
+    KeyedVector<programid, ProgramEntry*> mProgramEntries;
+    /// M: Used to check whether program binary service is enabled or not.
+    bool mEnableProgramBinaryService;
+    /// M: Used to check whether mProgramEntries is properly initialized.
+    bool mPorgramEntriesInitialized;
+};// class ProgramAtlas
+
+}; // namespace uirenderer
+}; // namespace android
+
+#endif // ANDROID_HWUI_PROGRAM_ATLAS_H
+
diff --git a/media/java/android/media/AudioSystem.java b/media/java/android/media/AudioSystem.java
index e08c290..dd3ac5a 100644
--- a/media/java/android/media/AudioSystem.java
+++ b/media/java/android/media/AudioSystem.java
@@ -823,5 +823,60 @@ public class AudioSystem
      * Keep in sync with core/jni/android_media_DeviceCallback.h.
      */
     final static int NATIVE_EVENT_ROUTING_CHANGE = 1000;
-}
 
+    /// zormax: Add for support EM
+    /**
+     * Set EM parameter.
+     *
+     * @param ptr The data to be set.
+     * @param length The data size.
+     * @return The status.
+     */
+    public static native int setEmParameter(byte[] ptr, int length);
+
+    /**
+     * Get EM parameter.
+     *
+     * @param ptr The data to be get.
+     * @param length The data size.
+     * @return The status.
+     */
+    public static native int getEmParameter(byte[] ptr, int length);
+
+    /**
+     * Set audio command.
+     *
+     * @param arg1 The first argument.
+     * @param arg2 The second argument.
+     * @return The status.
+     */
+    public static native int setAudioCommand(int arg1, int arg2);
+
+    /**
+     * Get audio command.
+     *
+     * @param arg1 The first argument.
+     * @return The status.
+     */
+    public static native int getAudioCommand(int arg1);
+
+    /**
+     * Set audio data.
+     *
+     * @param par1 The par1.
+     * @param len The length.
+     * @param ptr The array of audio data.
+     * @return The status.
+     */
+    public static native int setAudioData(int par1, int len, byte[] ptr);
+
+    /**
+     * Get audio data.
+     *
+     * @param par1 The par1.
+     * @param len The length of data..
+     * @param ptr The array to receive audio data.
+     * @return The status.
+     */
+    public static native int getAudioData(int par1, int len, byte[] ptr);
+}
\ No newline at end of file
diff --git a/services/usb/java/com/android/server/usb/UsbDeviceManager.java b/services/usb/java/com/android/server/usb/UsbDeviceManager.java
index bb08278..dc23a68 100644
--- a/services/usb/java/com/android/server/usb/UsbDeviceManager.java
+++ b/services/usb/java/com/android/server/usb/UsbDeviceManager.java
@@ -72,7 +72,7 @@ import java.util.Set;
 public class UsbDeviceManager {
 
     private static final String TAG = "UsbDeviceManager";
-    private static final boolean DEBUG = false;
+    private static final boolean DEBUG = true;
 
     /**
      * The persistent property which stores whether adb is enabled or not.
@@ -336,7 +336,7 @@ public class UsbDeviceManager {
         private boolean mSourcePower;
         private boolean mSinkPower;
         private boolean mConfigured;
-        private boolean mUsbDataUnlocked;
+        private boolean mUsbDataUnlocked = true;
         private String mCurrentFunctions;
         private boolean mCurrentFunctionsApplied;
         private UsbAccessory mCurrentAccessory;
@@ -782,7 +782,7 @@ public class UsbDeviceManager {
                         updateCurrentAccessory();
                     } else if (!mConnected) {
                         // restore defaults when USB is disconnected
-                        setEnabledFunctions(null, false, false);
+                        //setEnabledFunctions(null, false, false);
                     }
                     if (mBootCompleted) {
                         updateUsbStateBroadcastIfNeeded();
-- 
2.7.4

